---
title: "Distribución Uniforme Continua"
lang: es
---

```{=html}
<style>
main.content {
text-align: justify}
</style>
```



```{r}
#| include: false
#| label: setup

library(ggplot2)
library(dplyr)
library(knitr)
library(kableExtra)
library(plotly)

```


La **distribución uniforme continua** es una de las distribuciones de probabilidad más fundamentales en la teoría estadística. Se caracteriza por asignar la misma probabilidad a todos los valores dentro de un intervalo específico, de ahí su nombre *uniforme*.

Una variable aleatoria $X$ sigue una distribución uniforme continua en el intervalo $[a, b]$ si todos los subintervalos de igual longitud dentro de $[a, b]$ tienen la misma probabilidad de contener el valor de $X$.

::: {#def-unif_cont}

Decimos que una variable aleatoria $X$ tiene una distribución uniforme continua en el intervalo $[a, b]$, y escribimos $X\sim unif(a,b)$, si su función de densidad de probabilidad es constante en dicho intervalo y cero fuera de él, es decir:

\begin{equation}
f(x) = \begin{cases}
\frac{1}{b-a} & \text{si } a \leq x \leq b \\
0 & \text{en otro caso}
\end{cases}
\end{equation}

Los parámetros de la distribución son:

- $a$ es el **límite inferior** del intervalo (parámetro de localización)
- $b$ es el **límite superior** del intervalo (parámetro de escala)
- Se debe cumplir que $a < b$

:::

---

Nótese que la función de densidad de probabilidad cumple con las siguientes propiedades fundamentales:

1. **No negatividad**: $f(x) \geq 0$ para todo $x \in \mathbb{R}$
2. **Normalización**: $\int_{-\infty}^{\infty} f(x) dx = 1$



## Propiedades de la Función de Densidad de Probabilidad (PDF)

**Representación Gráfica**

La función de densidad de probabilidad tiene forma rectangular, de ahí que a veces se le llame *distribución rectangular*. A continuación se presentan gráficos de la función de densidad de probabilidad para diferentes parámetros.

```{r}
#| label: pdf-grafico

# Parámetros de ejemplo
a1 <- 1
b1 <- 4
a2 <- 0
b2 <- 6
a3 <- -2
b3 <- 2

# Crear datos para las gráficas
x_range <- seq(-3, 7, length.out = 1000)


# Crear dataframe para ggplot
df_pdf <- data.frame(
  x = rep(x_range, 3),
  d_prob = c(dunif(x_range, min = a1, max = b1),
        dunif(x_range, min = a2, max = b2),
        dunif(x_range, min = a3, max = b3)),
  Distribucion = rep(c("unif(1,4)", "unif(0,6)", "unif(-2,2)"), each = length(x_range))
)

pdf_graf <- ggplot(df_pdf) +
  geom_line(aes(x = x, y = d_prob, color = Distribucion), linewidth = 1.5) +
  labs(title = "PDF - Distribución Uniforme",
       x = "x", y = "f(x)",
       color = "Distribución") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        legend.position = "top") +
  scale_color_manual(values = c("firebrick", "dodgerblue2", "darkolivegreen"))


ggplotly(pdf_graf)
```



**Altura de la Función**

La altura de la función de densidad es inversamente proporcional a la longitud del intervalo:

- **Altura**: $h = \frac{1}{b-a}$
- **Base**: $\text{longitud} = b - a$
- **Área**: $h \times \text{longitud} = \frac{1}{b-a} \times (b-a) = 1$

```{r}
#| label: tabla-propiedades
# Tabla de propiedades para diferentes distribuciones uniformes
distribuciones <- data.frame(
  Distribucion = c("unif(0,1)", "unif(1,4)", "unif(-2,2)", "unif(0,10)"),
  a = c(0, 1, -2, 0),
  b = c(1, 4, 2, 10),
  Longitud = c(1, 3, 4, 10),
  Altura = c(1, 1/3, 1/4, 1/10)
)

kable(distribuciones, 
      caption = "Propiedades de diferentes distribuciones uniformes",
      digits = 4) |> 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

<br>

**Continuidad y Diferenciabilidad**

La función de densidad uniforme es:

- **Continua** en el interior del intervalo $(a, b)$
- **Discontinua** en los puntos $x = a$ y $x = b$
- **No diferenciable** en los puntos de discontinuidad

## Función de Distribución (CDF, Probabilidad Acumulada)


::: {#def-cdf_unif}

La función de distribución acumulativa (CDF) de una distribución uniforme continua $unif(a, b)$ está definida como:

\begin{equation}
F(x) = P(X \leq x) = \begin{cases} 
0 & \text{si } x < a \\
\frac{x-a}{b-a} & \text{si } a \leq x \leq b \\
1 & \text{si } x > b
\end{cases}
\end{equation}

:::

---

Para $x \in [a, b]$, la función de distribución se obtiene integrando la función de densidad:

\begin{equation}
F(x) = \int_{-\infty}^{x} f(t) dt = \int_{a}^{x} \frac{1}{b-a} dt = \frac{1}{b-a} \int_{a}^{x} dt = \frac{1}{b-a}(x-a) = \frac{x-a}{b-a}
\end{equation}


**Interpretación Geométrica**

Recordemos que la función de distribución representa la **proporción del intervalo total** que se encuentra a la izquierda del valor $x$:

- Cuando $x = a$: $F(a) = \frac{a-a}{b-a} = 0$
- Cuando $x = b$: $F(b) = \frac{b-a}{b-a} = 1$
- Para cualquier $x \in (a,b)$: $F(x) = \frac{x-a}{b-a}$ es la proporción lineal

**Representación Gráfica**

```{r}
#| label: cdf-grafico

# Crear dataframe para las CDF
df_cdf <- data.frame(
  x = rep(x_range, 3),
  y = c(punif(x_range, a1, b1),
        punif(x_range, a2, b2),
        punif(x_range, a3, b3)),
  Distribucion = rep(c("unif(1,4)", "unif(0,6)", "unif(-2,2)"), each = length(x_range))
)

cdf_graf <- ggplot(df_cdf) +
  geom_line(aes(x = x, y = y, color = Distribucion), linewidth = 1.5) +
  labs(title = "CDF's - Distribución Uniforme",
       x = "x", y = "F(x) = P(X ≤ x)",
       color = "Distribución") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        legend.position = "top") +
  scale_color_manual(values = c("firebrick", "dodgerblue2", "darkolivegreen")) +
  geom_hline(yintercept = c(0, 1), linetype = "dashed", alpha = 0.5)

ggplotly(cdf_graf)
```



**Propiedades Fundamentales de la Función de Distribución**

La función de distribución uniforme cumple con todas las propiedades de una CDF:

1. **Monótona no decreciente**: $F(x_1) \leq F(x_2)$ si $x_1 \leq x_2$
2. **Continua por la derecha**: $\lim_{h \to 0^+} F(x+h) = F(x)$
3. **Límites**: $\lim_{x \to -\infty} F(x) = 0$ y $\lim_{x \to \infty} F(x) = 1$

**Cálculo de Probabilidades**

La función de distribución permite calcular probabilidades de intervalos:

$$P(c \leq X \leq d) = F(d) - F(c)$$

Para la distribución uniforme, si $a \leq c \leq d \leq b$:

$$P(c \leq X \leq d) = \frac{d-a}{b-a} - \frac{c-a}{b-a} = \frac{d-c}{b-a}$$


Por ejemplo, para $X \sim unif(0, 10)$, la probabilidad de que $X$ esté entre 2 y 6 es:

```{r}
#| label: ejemplo-probabilidades

# Ejemplo: unif(0,10), calcular P(3 ≤ X ≤ 7)
a_ej <- 0; b_ej <- 10
c_ej <- 2; d_ej <- 6

prob_ejemplo <- punif(d_ej, min = a_ej, max= b_ej) - punif(c_ej, min = a_ej, max= b_ej)   

# Visualización del cálculo de probabilidad
x_ejemplo <- seq(-1, 11, length.out = 1000)
pdf_ejemplo <- dunif(x_ejemplo, a_ej, b_ej)

df_ejemplo <- data.frame(x = x_ejemplo, y = pdf_ejemplo)

ggplot(df_ejemplo, aes(x = x, y = y)) +
  geom_line(linewidth = 2, color = "blue") +
  geom_area(data = filter(df_ejemplo, x >= c_ej & x <= d_ej), 
            alpha = 0.5, fill = "red") +
  geom_vline(xintercept = c(c_ej, d_ej), linetype = "dashed", color = "red") +
  scale_x_continuous(breaks = seq(0, 10, by = 2)) +
  labs(title = paste0("P(2 ≤ X ≤ 6) = ", prob_ejemplo, " para unif(0,10)"),
       x = "x", y = "f(x)") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 12)) +
  annotate("text", x = 4, y = 0.05, 
           label = paste0("Área = ", prob_ejemplo), size = 5)
```


## Parámetros y Medidas Descriptivas

### Parámetros de la Distribución

La distribución uniforme continua $unif(a, b)$ está completamente caracterizada por dos parámetros:

- **$a$ (límite inferior)**: Parámetro de localización que determina el inicio del soporte
- **$b$ (límite superior)**: Parámetro que, junto con $a$, determina la escala y el final del soporte
- **Restricción**: Debe cumplirse que $a < b$

### Medidas de Tendencia Central

**Media (Esperanza)**


\begin{eqnarray}
\mu = E(X) & = & \int_{a}^{b} x \cdot \frac{1}{b-a} dx = \frac{1}{b-a} \int_{a}^{b} x dx\\
           & = & \frac{1}{b-a} \cdot \frac{x^2}{2}\Big|_a^b = \frac{1}{b-a} \cdot \frac{b^2-a^2}{2} = \frac{(b-a)(b+a)}{2(b-a)} = \frac{a+b}{2}
\end{eqnarray}

Luego,

$$\mu = \frac{a+b}{2}$$

La media es exactamente el **punto medio** del intervalo $[a, b]$.

<br>

**Mediana**

Para la distribución uniforme, la mediana $M$ satisface $P(X \leq M) = 0.5$:

$$F(M) = \frac{M-a}{b-a} = 0.5$$

$$M-a = \frac{b-a}{2} \Rightarrow M = a + \frac{b-a}{2} = \frac{a+b}{2}$$

Por lo tanto, la mediana coincide con la media:

$$\text{Mediana} = \frac{a+b}{2}$$



### Medidas de Dispersión

**Varianza**

La varianza se calcula como $\text{Var}(X) = E(X^2) - (E[X])^2$.

Primero calculamos $E(X^2)$:

\begin{eqnarray}
E(X^2) & = & \int_{a}^{b} x^2 \cdot \frac{1}{b-a} dx = \frac{1}{b-a} \int_{a}^{b} x^2 dx = \frac{1}{b-a} \cdot \frac{x^3}{3}\Big|_a^b\\
       & = & \frac{1}{b-a} \cdot \frac{b^3-a^3}{3} = \frac{b^3-a^3}{3(b-a)}
\end{eqnarray}

Usando la identidad $b^3-a^3 = (b-a)(b^2+ab+a^2)$:

$$E(X^2) = \frac{(b-a)(b^2+ab+a^2)}{3(b-a)} = \frac{b^2+ab+a^2}{3}$$

Por lo tanto:

$$\text{Var}(X) = \frac{b^2+ab+a^2}{3} - \left(\frac{a+b}{2}\right)^2$$

Simplificando, tenemos

$$\text{Var}(X) = \frac{(b-a)^2}{12}$$


<br>

**Desviación Estándar**

$$\sigma = \sqrt{\text{Var}(X)} = \frac{b-a}{\sqrt{12}} = \frac{b-a}{2\sqrt{3}}$$



## Simulación y Comparación con Parámetros Teóricos


Consideremos una distribución $unif(2, 8)$ y generemos diferentes tamaños de muestra:

```{r simulacion-basica}
# Parámetros de la distribución U(2, 8)
a <- 2
b <- 8

# Parámetros teóricos
media_teorica <- (a + b) / 2
varianza_teorica <- (b - a)^2 / 12
desv_std_teorica <- sqrt(varianza_teorica)

# Tamaños de muestra a evaluar
tamaños <- c(100, 500, 1000, 5000, 10000)

# Función para simular y calcular estadísticos
simular_uniforme <- function(n, a, b) {
  muestra <- runif(n, min = a, max = b)
  
  return(data.frame(
    n = n,
    media_muestral = mean(muestra),
    varianza_muestral = var(muestra),
    desv_std_muestral = sd(muestra),
    minimo = min(muestra),
    maximo = max(muestra)
  ))
}

# Realizar simulaciones
resultados_sim <- do.call(rbind, lapply(tamaños, simular_uniforme, a = a, b = b))

# Agregar valores teóricos para comparación
resultados_sim$media_teorica <- media_teorica
resultados_sim$varianza_teorica <- varianza_teorica
resultados_sim$desv_std_teorica <- desv_std_teorica

# Mostrar resultados
kable(resultados_sim, 
      caption = "Comparación de estadísticos muestrales vs teóricos para U(2,8)",
      digits = 4) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

**Visualización de la Convergencia**

```{r convergencia-visual}
# Generar una secuencia larga para observar convergencia
n_total <- 10000
muestra_larga <- runif(n_total, min = a, max = b)

# Calcular medias acumuladas
indices <- 1:n_total
medias_acumuladas <- cumsum(muestra_larga) / indices

# Crear dataframe para gráfico
df_convergencia <- data.frame(
  n = indices,
  media_acumulada = medias_acumuladas,
  media_teorica = media_teorica
)

# Gráfico de convergencia de la media
ggplot(df_convergencia, aes(x = n)) +
  geom_line(aes(y = media_acumulada), color = "blue", alpha = 0.7) +
  geom_hline(aes(yintercept = media_teorica), color = "red", linetype = "dashed", linewidth = 1) +
  labs(title = "Convergencia de la Media Muestral hacia la Media Teórica",
       subtitle = "Distribución U(2,8) - Ley de los Grandes Números",
       x = "Tamaño de muestra (n)",
       y = "Media acumulada",
       caption = "Línea roja: Media teórica = 5") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

**Histograma vs Densidad Teórica**

```{r histograma-densidad}
#| warning: false
# Generar muestra grande para el histograma
muestra_hist <- runif(5000, min = a, max = b)

# Crear histograma
ggplot(data.frame(x = muestra_hist), aes(x = x)) +
  geom_histogram(aes(y = after_stat(density)), binwidth = 0.5, 
                 fill = "lightblue", color = "black", alpha = 0.7, boundary = a) +
  geom_hline(yintercept = 1/(b-a), color = "red", size = 2, linetype = "dashed") +
  labs(title = "Histograma de Muestra vs Densidad Teórica",
       subtitle = "5000 observaciones de unif(2,8)",
       x = "Valores",
       y = "Densidad",
       caption = "Línea roja: Densidad teórica = 1/6 ≈ 0.167") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  xlim(1.5, 8.5)
```

## Ejemplos Prácticos

::: {#exm-semaforo}

### Tiempo de Espera en Semáforo

Un semáforo tiene un ciclo de 60 segundos, donde 25 segundos está en verde y 35 segundos en rojo. Si llegamos al semáforo en un momento aleatorio durante la fase roja, el tiempo de espera sigue una distribución uniforme.

```{r ejemplo-semaforo}
# Parámetros del problema
tiempo_rojo <- 35  # segundos
a_semaforo <- 0
b_semaforo <- tiempo_rojo

# Simular 1000 llegadas aleatorias durante fase roja
n_llegadas <- 1000
tiempos_espera <- runif(n_llegadas, min = a_semaforo, max = b_semaforo)

# Calcular estadísticos
tiempo_promedio <- mean(tiempos_espera)
tiempo_teorico <- (a_semaforo + b_semaforo) / 2

# Probabilidad de esperar menos de 10 segundos
prob_menos_10 <- mean(tiempos_espera < 10)
prob_teorica_menos_10 <- (10 - a_semaforo) / (b_semaforo - a_semaforo)

# Resultados
cat("=== ANÁLISIS DE TIEMPO DE ESPERA EN SEMÁFORO ===\n")
cat("Tiempo de espera promedio (simulado):", round(tiempo_promedio, 2), "segundos\n")
cat("Tiempo de espera teórico:", tiempo_teorico, "segundos\n")
cat("Probabilidad de esperar < 10 seg (simulada):", round(prob_menos_10, 3), "\n")
cat("Probabilidad teórica de esperar < 10 seg:", round(prob_teorica_menos_10, 3), "\n")

# Visualización
ggplot(data.frame(tiempo = tiempos_espera), aes(x = tiempo)) +
  geom_histogram(aes(y = after_stat(density)), bins = 20, 
                 fill = "orange", color = "black", alpha = 0.7) +
  geom_vline(xintercept = tiempo_teorico, color = "red", size = 1, linetype = "dashed") +
  geom_vline(xintercept = 10, color = "blue", size = 1, linetype = "dotted") +
  labs(title = "Distribución de Tiempos de Espera en Semáforo",
       x = "Tiempo de espera (segundos)",
       y = "Densidad",
       caption = "Línea roja: Media teórica | Línea azul: 10 segundos") +
  theme_minimal()
```

:::


::: {#exm-manufactura}

### Control de Calidad en Manufactura

En una línea de producción, el diámetro de las piezas debe estar entre 19.8 mm y 20.2 mm. Si el proceso está bien calibrado, los diámetros siguen una distribución uniforme en este rango.

```{r ejemplo-manufactura}
# Parámetros del proceso
diametro_min <- 19.8  # mm
diametro_max <- 20.2  # mm
diametro_objetivo <- 20.0  # mm

# Simular producción de 2000 piezas
n_piezas <- 2000
diametros <- runif(n_piezas, min = diametro_min, max = diametro_max)

# Análisis de calidad
tolerancia <- 0.1  # ±0.1 mm del objetivo
piezas_en_tolerancia <- sum(abs(diametros - diametro_objetivo) <= tolerancia)
porcentaje_calidad <- (piezas_en_tolerancia / n_piezas) * 100

# Cálculo teórico de calidad
limite_inf_tolerancia <- diametro_objetivo - tolerancia
limite_sup_tolerancia <- diametro_objetivo + tolerancia
porcentaje_teorico <- ((limite_sup_tolerancia - limite_inf_tolerancia) / 
                      (diametro_max - diametro_min)) * 100

# Estadísticos del proceso
promedio_diametro <- mean(diametros)
desviacion_diametro <- sd(diametros)

# Resultados
cat("=== ANÁLISIS DE CONTROL DE CALIDAD ===\n")
cat("Diámetro promedio:", round(promedio_diametro, 4), "mm\n")
cat("Desviación estándar:", round(desviacion_diametro, 4), "mm\n")
cat("Piezas dentro de tolerancia:", piezas_en_tolerancia, "de", n_piezas, "\n")
cat("Porcentaje de calidad (simulado):", round(porcentaje_calidad, 1), "%\n")
cat("Porcentaje teórico de calidad:", round(porcentaje_teorico, 1), "%\n")

# Visualización del control de calidad
ggplot(data.frame(diametro = diametros), aes(x = diametro)) +
  geom_histogram(aes(y = after_stat(density)), bins = 25, 
                 fill = "lightgreen", color = "black", alpha = 0.7) +
  geom_vline(xintercept = diametro_objetivo, color = "red", size = 1) +
  geom_vline(xintercept = c(limite_inf_tolerancia, limite_sup_tolerancia), 
             color = "blue", size = 1, linetype = "dashed") +
  annotate("rect", xmin = limite_inf_tolerancia, xmax = limite_sup_tolerancia,
           ymin = 0, ymax = Inf, alpha = 0.2, fill = "green") +
  labs(title = "Distribución de Diámetros en Control de Calidad",
       x = "Diámetro (mm)",
       y = "Densidad",
       caption = "Zona verde: Tolerancia aceptable | Línea roja: Objetivo") +
  theme_minimal()
```

:::

---

## Verificación del Teorema Central del Límite

El Teorema Central del Límite establece que las medias muestrales de cualquier distribución (con media y varianza finitas) se aproximan a una distribución normal cuando el tamaño de muestra es suficientemente grande.

### Simulación con Diferentes Tamaños de Muestra

```{r tcl-simulacion}
# Parámetros de la distribución uniforme
a_tcl <- 0
b_tcl <- 10
media_poblacional <- (a_tcl + b_tcl) / 2
varianza_poblacional <- (b_tcl - a_tcl)^2 / 12

# Diferentes tamaños de muestra
tamaños_muestra <- c(5, 10, 30, 50, 100)
num_muestras <- 1000  # Número de medias muestrales a generar

# Función para generar medias muestrales
generar_medias <- function(n, num_sim, a, b) {
  medias <- replicate(num_sim, mean(runif(n, min = a, max = b)))
  return(medias)
}

# Generar medias para cada tamaño de muestra
resultados_tcl <- list()
for (i in seq_along(tamaños_muestra)) {
  n <- tamaños_muestra[i]
  medias <- generar_medias(n, num_muestras, a_tcl, b_tcl)
  
  resultados_tcl[[i]] <- data.frame(
    medias = medias,
    n = n,
    varianza_teorica_media = varianza_poblacional / n,
    desv_std_teorica_media = sqrt(varianza_poblacional / n)
  )
}

# Combinar resultados
df_tcl <- do.call(rbind, resultados_tcl)
df_tcl$n_factor <- factor(paste("n =", df_tcl$n))
```

### Visualización de la Normalización

```{r tcl-visualizacion}
# Gráfico de histogramas para diferentes tamaños de muestra
ggplot(df_tcl, aes(x = medias)) +
  geom_histogram(aes(y = after_stat(density)), bins = 30, 
                 fill = "lightblue", color = "black", alpha = 0.7) +
  geom_vline(xintercept = media_poblacional, color = "red", size = 1, linetype = "dashed") +
  facet_wrap(~n_factor, scales = "free_y", ncol = 3) +
  labs(title = "Teorema Central del Límite - Distribución de Medias Muestrales",
       subtitle = "Distribución U(0,10) con diferentes tamaños de muestra",
       x = "Media muestral",
       y = "Densidad") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

### Comparación de Varianzas

```{r tcl-varianzas}
# Calcular estadísticos para cada tamaño de muestra
estadisticos_tcl <- df_tcl %>%
  group_by(n) %>%
  summarise(
    media_observada = mean(medias),
    varianza_observada = var(medias),
    desv_std_observada = sd(medias),
    varianza_teorica = first(varianza_teorica_media),
    desv_std_teorica = first(desv_std_teorica_media),
    .groups = 'drop'
  )

# Mostrar tabla de comparación
kable(estadisticos_tcl, 
      caption = "Comparación de varianzas teóricas vs observadas",
      digits = 4) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

# Gráfico de convergencia de varianzas
ggplot(estadisticos_tcl, aes(x = n)) +
  geom_point(aes(y = varianza_observada, color = "Observada"), size = 3) +
  geom_line(aes(y = varianza_observada, color = "Observada"), size = 1) +
  geom_point(aes(y = varianza_teorica, color = "Teórica"), size = 3) +
  geom_line(aes(y = varianza_teorica, color = "Teórica"), size = 1) +
  scale_color_manual(values = c("Observada" = "blue", "Teórica" = "red")) +
  labs(title = "Disminución de la Varianza de las Medias Muestrales",
       subtitle = "Var(X̄) = σ²/n",
       x = "Tamaño de muestra (n)",
       y = "Varianza de las medias",
       color = "Tipo") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

### Prueba de Normalidad de las Medias

```{r tcl-normalidad}
# Realizar pruebas de normalidad para n=100
medias_n100 <- df_tcl[df_tcl$n == 100, "medias"]

# Prueba de Shapiro-Wilk
shapiro_test <- shapiro.test(medias_n100)

# Q-Q plot para n=100
ggplot(data.frame(medias = medias_n100), aes(sample = medias)) +
  geom_qq() +
  geom_qq_line(color = "red", size = 1) +
  labs(title = "Q-Q Plot - Medias Muestrales (n=100)",
       subtitle = paste("Prueba Shapiro-Wilk: W =", round(shapiro_test$statistic, 4), 
                       ", p-valor =", round(shapiro_test$p.value, 4)),
       x = "Cuantiles teóricos (Normal)",
       y = "Cuantiles observados") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

## Ejercicios Propuestos

::: {#exr-tiempo_carga}

### Análisis de Tiempo de Carga

El tiempo de carga de una página web sigue una distribución uniforme entre 2 y 8 segundos.

 1. Crear un histograma de los tiempos de carga simulados (n=1000) y superponer la densidad teórica.
 2. Cuál es el percentil 75 de los tiempos de carga?
 3. ¿Cuál es la probabilidad de que una página cargue en menos de 4 segundos?

```{r}
a_carga <- 2
b_carga <- 8
n_simulaciones <- 1000

set.seed(456)
tiempos_carga <- runif(n_simulaciones, min = a_carga, max = b_carga)

tiempo_promedio <- mean(tiempos_carga)
tiempo_teorico <- (a_carga + b_carga) / 2
tiempo_mediana <- median(tiempos_carga)
tiempo_sd <- sd(tiempos_carga)

cat("ANÁLISIS DE TIEMPOS DE CARGA\n")
cat("Tiempo promedio (simulado):", round(tiempo_promedio, 3), "segundos\n")
cat("Tiempo teórico (media):", tiempo_teorico, "segundos\n")
cat("Mediana:", round(tiempo_mediana, 3), "segundos\n")
cat("Desviación estándar:", round(tiempo_sd, 3), "segundos\n\n")
```

```{r}
# 1.
cat("Ejercicio 1\n")
dist_uniforme <- data.frame(
  x = seq(a_carga, b_carga, length = 1000),
  densidad = dunif(seq(a_carga, b_carga, length = 1000), min = a_carga, max = b_carga)
)

densidad_teorica <- 1 / (b_carga - a_carga)

p1 <- ggplot(data.frame(tiempo = tiempos_carga), aes(x = tiempo)) +
  geom_histogram(aes(y = after_stat(density)), bins = 30, 
                 fill = "#56B4E9", color = "black", alpha = 0.7) +
  geom_line(data = dist_uniforme, aes(x = x, y = densidad),
            color = "darkred", size = 1.5) +
  geom_hline(yintercept = densidad_teorica, 
             color = "red", size = 1.2, linetype = "dashed") +
  geom_vline(xintercept = tiempo_teorico, 
             color = "blue", size = 1, linetype = "dotted") +
  annotate("label", x = tiempo_teorico + 0.5, y = 0.15, 
           label = paste("Media =", tiempo_teorico, "seg"),
           fill = "lightblue", size = 3.5) +
  annotate("label", x = 3, y = densidad_teorica + 0.02, 
           label = paste("Densidad teórica = 1/6 =", round(densidad_teorica, 3)),
           fill = "pink", size = 3.5) +
  labs(title = "Distribución de Tiempos de Carga de Página Web",
       subtitle = "Línea roja: Densidad teórica | Línea azul: Media",
       x = "Tiempo de carga (segundos)",
       y = "Densidad") +
  scale_x_continuous(breaks = seq(2, 8, by = 1)) +
  theme_minimal()

p1
```

```{r}
# 2. 
cat("Ejercicio 2\n")
percentil_75_simulado <- quantile(tiempos_carga, 0.75)

percentil_75_teorico <- a_carga + 0.75 * (b_carga - a_carga)

cat("PERCENTIL 75:\n")
cat("Simulado:", round(percentil_75_simulado, 3), "segundos\n")
cat("Teórico:", percentil_75_teorico, "segundos\n")
cat("Diferencia:", round(abs(percentil_75_simulado - percentil_75_teorico), 3), "segundos\n")
cat("Interpretación: El 75% de las páginas cargan en", round(percentil_75_teorico, 2), 
    "segundos o menos\n\n")

# Gráfico percentil 75
p2 <- ggplot(data.frame(tiempo = tiempos_carga), aes(x = tiempo)) +
  geom_histogram(aes(y = after_stat(density)), bins = 30, 
                 fill = "#56B4E9", color = "black", alpha = 0.7) +
  geom_line(data = dist_uniforme, aes(x = x, y = densidad),
            color = "darkred", size = 1.5) +
  geom_vline(xintercept = percentil_75_teorico, 
             color = "darkgreen", size = 1.2, linetype = "dashed") +
  geom_area(data = dist_uniforme %>% filter(x <= percentil_75_teorico),
            aes(x = x, y = densidad), fill = "green", alpha = 0.3) +
  annotate("label", x = percentil_75_teorico - 0.5, y = 0.14, 
           label = paste("P75 =", percentil_75_teorico, "seg"),
           fill = "lightgreen", size = 4) +
  annotate("text", x = 4.5, y = 0.10, 
           label = "75% de las páginas\ncargan en este tiempo\no menos",
           size = 3.5, fontface = "bold") +
  labs(title = "Percentil 75 de Tiempos de Carga",
       subtitle = "El área verde representa el 75% de los datos",
       x = "Tiempo de carga (segundos)",
       y = "Densidad") +
  scale_x_continuous(breaks = seq(2, 8, by = 1)) +
  theme_minimal()

p2
```

```{r}
# 3.
cat("Ejercicio 3\n")
umbral <- 4

n_menos_4 <- sum(tiempos_carga < umbral)
prob_simulada_menos_4 <- mean(tiempos_carga < umbral)

# Probabilidad teórica: P(X < 4) = (4 - 2) / (8 - 2)
prob_teorica_menos_4 <- (umbral - a_carga) / (b_carga - a_carga)

cat("PROBABILIDAD DE CARGA < 4 SEGUNDOS\n")
cat("Páginas que cargan en < 4 seg:", n_menos_4, "de", n_simulaciones, "\n")
cat("Probabilidad simulada:", round(prob_simulada_menos_4, 4), 
    "(", round(prob_simulada_menos_4 * 100, 2), "%)\n")
cat("Probabilidad teórica:", round(prob_teorica_menos_4, 4), 
    "(", round(prob_teorica_menos_4 * 100, 2), "%)\n")
cat("Diferencia:", round(abs(prob_simulada_menos_4 - prob_teorica_menos_4), 4), "\n\n")


# Gráfico mostrando P(X < 4)
p3 <- ggplot(data.frame(tiempo = tiempos_carga), aes(x = tiempo)) +
  geom_histogram(aes(y = after_stat(density)), bins = 30, 
                 fill = "#56B4E9", color = "black", alpha = 0.7) +
  geom_line(data = dist_uniforme, aes(x = x, y = densidad),
            color = "darkred", size = 1.5) +
  geom_vline(xintercept = umbral, 
             color = "purple", size = 1.2, linetype = "dashed") +
  geom_area(data = dist_uniforme %>% filter(x < umbral),
            aes(x = x, y = densidad), fill = "purple", alpha = 0.4) +
  geom_area(data = dist_uniforme %>% filter(x >= umbral),
            aes(x = x, y = densidad), fill = "orange", alpha = 0.3) +
  annotate("label", x = 3, y = 0.14, 
           label = paste("P(X < 4) =", round(prob_teorica_menos_4, 3)),
           fill = "plum", size = 4) +
  annotate("label", x = 6, y = 0.14, 
           label = paste("P(X ≥ 4) =", round(1 - prob_teorica_menos_4, 3)),
           fill = "lightyellow", size = 4) +
  annotate("text", x = umbral, y = 0.005, 
           label = "4 segundos", angle = 90, vjust = -0.5, 
           color = "purple", fontface = "bold") +
  labs(title = "Probabilidad de Carga Menor a 4 Segundos",
       subtitle = "Área morada: P(X < 4) | Área naranja: P(X ≥ 4)",
       x = "Tiempo de carga (segundos)",
       y = "Densidad") +
  scale_x_continuous(breaks = seq(2, 8, by = 1)) +
  theme_minimal()

p3
```



:::


::: {#exr-calificaciones}

### Distribución de Calificaciones

En un examen muy fácil, las calificaciones se distribuyen uniformemente entre 70 y 100 puntos.

 1. Simular calificaciones de 500 estudiantes
 2. ¿Qué porcentaje de estudiantes obtiene calificación superior a 85?
 3. Crear categorías: Aprobado (70-79), Bien (80-89), Excelente (90-100) y calcular el porcentaje en cada categoría
 4. Comparar con los porcentajes teóricos
 5. Graficar la distribución con las categorías marcadas

```{r}
a_calif <- 70
b_calif <- 100
n_estudiantes <- 500

# 1.
cat("Ejercicio 1\n")
set.seed(123)
calificaciones <- runif(n_estudiantes, min = a_calif, max = b_calif)

calif_promedio <- mean(calificaciones)
calif_teorica <- (a_calif + b_calif) / 2
calif_mediana <- median(calificaciones)
calif_sd <- sd(calificaciones)

cat("ANÁLISIS DE CALIFICACIONES\n")
cat("Calificación promedio (simulada):", round(calif_promedio, 2), "puntos\n")
cat("Calificación teórica (media):", calif_teorica, "puntos\n")
cat("Mediana:", round(calif_mediana, 2), "puntos\n")
cat("Desviación estándar:", round(calif_sd, 2), "puntos\n\n")
```

```{r}
# 2.
cat("Ejercicio 2\n")
umbral <- 85

estudiantes_mayor_85 <- sum(calificaciones > umbral)
porcentaje_mayor_85 <- (estudiantes_mayor_85 / n_estudiantes) * 100

porcentaje_teorico_85 <- ((b_calif - umbral) / (b_calif - a_calif)) * 100

cat("CALIFICACIONES SUPERIORES A 85\n")
cat("Estudiantes con calificación > 85:", estudiantes_mayor_85, "de", n_estudiantes, "\n")
cat("Porcentaje simulado:", round(porcentaje_mayor_85, 2), "%\n")
cat("Porcentaje teórico:", round(porcentaje_teorico_85, 2), "%\n\n")
```

```{r}
# 3.
cat("Ejercicio 3\n")
calificaciones_df <- data.frame(calificacion = calificaciones) %>%
  mutate(categoria = case_when(
    calificacion >= 90 ~ "Excelente",
    calificacion >= 80 ~ "Bien",
    TRUE ~ "Aprobado"
  ))

resumen_categorias <- calificaciones_df %>%
  group_by(categoria) %>%
  summarise(
    n_estudiantes = n(),
    porcentaje_simulado = (n() / n_estudiantes) * 100
  ) %>%
  arrange(desc(categoria))

cat("DISTRIBUCIÓN POR CATEGORÍAS (SIMULADA)\n")
print(resumen_categorias)
cat("\n")
```

```{r}
# 4. 
cat("Ejercicio 4\n")
porcentaje_teorico_aprobado <- ((80 - 70) / (100 - 70)) * 100
porcentaje_teorico_bien <- ((90 - 80) / (100 - 70)) * 100
porcentaje_teorico_excelente <- ((100 - 90) / (100 - 70)) * 100

tabla_comparacion <- data.frame(
  Categoria = c("Aprobado (70-79)", "Bien (80-89)", "Excelente (90-100)"),
  Porcentaje_Simulado = c(
    resumen_categorias$porcentaje_simulado[resumen_categorias$categoria == "Aprobado"],
    resumen_categorias$porcentaje_simulado[resumen_categorias$categoria == "Bien"],
    resumen_categorias$porcentaje_simulado[resumen_categorias$categoria == "Excelente"]
  ),
  Porcentaje_Teorico = c(porcentaje_teorico_aprobado, 
                         porcentaje_teorico_bien, 
                         porcentaje_teorico_excelente),
  Diferencia = c(
    resumen_categorias$porcentaje_simulado[resumen_categorias$categoria == "Aprobado"] - porcentaje_teorico_aprobado,
    resumen_categorias$porcentaje_simulado[resumen_categorias$categoria == "Bien"] - porcentaje_teorico_bien,
    resumen_categorias$porcentaje_simulado[resumen_categorias$categoria == "Excelente"] - porcentaje_teorico_excelente
  )
)

cat("COMPARACIÓN: SIMULADO VS TEÓRICO\n")
kable(tabla_comparacion, 
      digits = 2,
      col.names = c("Categoría", "% Simulado", "% Teórico", "Diferencia"),
      align = "c") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE)
```

```{r}
# 5. 
cat("Ejercicio 5\n")
p1 <- ggplot(calificaciones_df, aes(x = calificacion)) +
  geom_histogram(aes(y = after_stat(density), fill = categoria), 
                 bins = 30, color = "black", alpha = 0.7) +
  geom_hline(yintercept = 1/(b_calif - a_calif), 
             color = "red", size = 1.2, linetype = "dashed") +
  geom_vline(xintercept = 80, color = "blue", size = 1, linetype = "dotted") +
  geom_vline(xintercept = 90, color = "blue", size = 1, linetype = "dotted") +
  geom_vline(xintercept = umbral, color = "darkgreen", size = 1, linetype = "dashed") +
  scale_fill_manual(values = c("Aprobado" = "#FFA07A", 
                                "Bien" = "#87CEEB", 
                                "Excelente" = "#90EE90"),
                    name = "Categoría") +
  annotate("text", x = 75, y = 0.028, label = "Aprobado\n70-79", 
           size = 3.5, fontface = "bold") +
  annotate("text", x = 85, y = 0.028, label = "Bien\n80-89", 
           size = 3.5, fontface = "bold") +
  annotate("text", x = 95, y = 0.028, label = "Excelente\n90-100", 
           size = 3.5, fontface = "bold") +
  labs(title = "Distribución Uniforme de Calificaciones",
       subtitle = paste("Línea roja: Densidad teórica (1/30) | Verde: Umbral 85 puntos"),
       x = "Calificación",
       y = "Densidad") +
  theme_minimal() +
  theme(legend.position = "top")

p1
```

```{r}
p2 <- ggplot(tabla_comparacion, aes(x = Categoria)) +
  geom_col(aes(y = Porcentaje_Simulado, fill = "Simulado"), 
           alpha = 0.7, position = position_dodge(width = 0.8), width = 0.4) +
  geom_col(aes(y = Porcentaje_Teorico, fill = "Teórico"), 
           alpha = 0.7, position = position_dodge(width = 0.8), width = 0.4) +
  geom_text(aes(y = Porcentaje_Simulado, label = paste0(round(Porcentaje_Simulado, 1), "%")),
            vjust = -0.5, size = 3.5, fontface = "bold") +
  scale_fill_manual(values = c("Simulado" = "#56B4E9", "Teórico" = "#E69F00"),
                    name = "") +
  labs(title = "Comparación: Porcentajes Simulados vs Teóricos",
       x = "Categoría",
       y = "Porcentaje (%)") +
  theme_minimal() +
  theme(legend.position = "top")

p2


# Gráfico de densidad con áreas coloreadas
dist_uniforme <- data.frame(
  x = seq(a_calif, b_calif, length = 1000),
  densidad = dunif(seq(a_calif, b_calif, length = 1000), min = a_calif, max = b_calif)
)

p3 <- ggplot() +
  geom_rect(aes(xmin = 70, xmax = 80, ymin = 0, ymax = 1/30), 
            fill = "#FFA07A", alpha = 0.4) +
  geom_rect(aes(xmin = 80, xmax = 90, ymin = 0, ymax = 1/30), 
            fill = "#87CEEB", alpha = 0.4) +
  geom_rect(aes(xmin = 90, xmax = 100, ymin = 0, ymax = 1/30), 
            fill = "#90EE90", alpha = 0.4) +
  geom_line(data = dist_uniforme, aes(x = x, y = densidad),
            color = "darkred", size = 1.5) +
  geom_vline(xintercept = umbral, color = "darkgreen", 
             size = 1.2, linetype = "dashed") +
  annotate("text", x = 75, y = 0.028, label = "Aprobado", 
           size = 4, fontface = "bold") +
  annotate("text", x = 85, y = 0.028, label = "Bien", 
           size = 4, fontface = "bold") +
  annotate("text", x = 95, y = 0.028, label = "Excelente", 
           size = 4, fontface = "bold") +
  annotate("label", x = 88, y = 0.025, 
           label = paste0("P(X > 85) = ", round(porcentaje_teorico_85, 1), "%"),
           fill = "lightgreen", size = 3.5) +
  labs(title = "Función de Densidad Uniforme con Categorías",
       x = "Calificación",
       y = "Densidad") +
  scale_x_continuous(breaks = seq(70, 100, by = 5)) +
  theme_minimal()

p3

```



:::

---

::: {#exr-tcl_verificacion}


### Verificación del TCL con Distribución Asimétrica

Crear una distribución uniforme "truncada" y verificar el TCL.

 1. Generar muestras de unif(0,1) pero solo conservar valores > 0.3 (esto creará una distribución sesgada)
 2. Para tamaños de muestra n = c(5, 15, 30, 60, 120):

    - Generar 800 medias muestrales de cada tamaño
    - Crear histogramas mostrando la normalización
    - Calcular skewness y kurtosis de las distribuciones de medias

 3. ¿A partir de qué tamaño de muestra la distribución de medias se ve aproximadamente normal?

```{r}
# 1.
cat("Ejercicio 1\n")
set.seed(789)

generar_muestra_truncada <- function(n) {
  muestra <- runif(n * 2, min = 0, max = 1)
  muestra_truncada <- muestra[muestra > 0.3]
  return(muestra_truncada[1:n])
}

# Parámetros poblacionales (U(0.3, 1))
media_poblacional <- (0.3 + 1) / 2
sd_poblacional <- sqrt((1 - 0.3)^2 / 12)

cat("DISTRIBUCIÓN POBLACIONAL: U(0.3, 1)\n")
cat("Media:", media_poblacional, "\n")
cat("SD:", round(sd_poblacional, 4), "\n\n")

muestra_grande <- generar_muestra_truncada(10000)
ggplot(data.frame(x = muestra_grande), aes(x = x)) +
  geom_histogram(aes(y = after_stat(density)), bins = 40,
                 fill = "#E69F00", color = "black", alpha = 0.7) +
  geom_vline(xintercept = media_poblacional, 
             color = "red", size = 1.2, linetype = "dashed") +
  labs(title = "Distribución Poblacional: U(0,1) Truncada en X > 0.3",
       subtitle = "Distribución sesgada a la derecha",
       x = "Valor", y = "Densidad") +
  theme_minimal()
```

```{r}
# 2.
cat("Ejercicio 2\n")
calc_skewness <- function(x) {
  n <- length(x)
  m <- mean(x)
  s <- sd(x)
  sum((x - m)^3 / s^3) / n
}

calc_kurtosis <- function(x) {
  n <- length(x)
  m <- mean(x)
  s <- sd(x)
  sum((x - m)^4 / s^4) / n
}

tamanos_muestra <- c(5, 15, 30, 60, 120)
num_simulaciones <- 800

resultados <- list()

for(i in seq_along(tamanos_muestra)) {
  n <- tamanos_muestra[i]
  
  medias <- replicate(num_simulaciones, {
    muestra <- generar_muestra_truncada(n)
    mean(muestra)
  })
  
  resultados[[i]] <- data.frame(
    n = n,
    medias = medias,
    skewness = calc_skewness(medias),
    kurtosis = calc_kurtosis(medias)
  )
  
  cat("n =", n, "\n")
  cat("  Skewness:", round(calc_skewness(medias), 4), "\n")
  cat("  Kurtosis:", round(calc_kurtosis(medias), 4), "\n\n")
}

df_tcl <- bind_rows(resultados)
df_tcl$n_factor <- factor(paste("n =", df_tcl$n), 
                          levels = paste("n =", tamanos_muestra))

# Histogramas con curva normal para cada n
ggplot(df_tcl, aes(x = medias)) +
  geom_histogram(aes(y = after_stat(density)), bins = 30,
                 fill = "lightblue", color = "black", alpha = 0.7) +
  geom_vline(xintercept = media_poblacional, 
             color = "red", size = 1, linetype = "dashed") +
  facet_wrap(~n_factor, scales = "free_y", ncol = 3) +
  labs(title = "Teorema Central del Límite - Distribución Uniforme Truncada",
       subtitle = "U(0,1) truncada en X > 0.3 | Línea roja: media poblacional",
       x = "Media muestral",
       y = "Densidad") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

tabla_stats <- data.frame(
  n = tamanos_muestra,
  Skewness = sapply(resultados, function(x) round(x$skewness[1], 4)),
  Kurtosis = sapply(resultados, function(x) round(x$kurtosis[1], 4))
)

kable(tabla_stats,
      align = "c",
      caption = "Skewness y Kurtosis por Tamaño de Muestra") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE) %>%
  footnote(general = "Normal: Skewness ≈ 0, Kurtosis ≈ 3")

# Gráfico de evolución
evolucion <- data.frame(
  n = tamanos_muestra,
  skewness = sapply(resultados, function(x) x$skewness[1]),
  kurtosis = sapply(resultados, function(x) x$kurtosis[1])
)

p1 <- ggplot(evolucion, aes(x = n, y = skewness)) +
  geom_line(color = "#E69F00", size = 1.2) +
  geom_point(color = "#E69F00", size = 3) +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
  annotate("text", x = 70, y = 0.1, label = "Normal: Skewness = 0",
           color = "red") +
  labs(title = "Evolución del Skewness", x = "Tamaño de muestra (n)", y = "Skewness") +
  theme_minimal()

p2 <- ggplot(evolucion, aes(x = n, y = kurtosis)) +
  geom_line(color = "#56B4E9", size = 1.2) +
  geom_point(color = "#56B4E9", size = 3) +
  geom_hline(yintercept = 3, color = "red", linetype = "dashed") +
  annotate("text", x = 70, y = 3.3, label = "Normal: Kurtosis = 3",
           color = "red") +
  labs(title = "Evolución de la Kurtosis", x = "Tamaño de muestra (n)", y = "Kurtosis") +
  theme_minimal()

gridExtra::grid.arrange(p1, p2, ncol = 2)
```

```{r}
# 3. 
cat("Ejercicio 3\n")
cat("CONCLUSIÓN\n")
for(i in seq_along(tamanos_muestra)) {
  n <- tamanos_muestra[i]
  skew <- resultados[[i]]$skewness[1]
  kurt <- resultados[[i]]$kurtosis[1]
  
  es_normal <- (abs(skew) < 0.5) && (abs(kurt - 3) < 0.5)
  
  cat("n =", n, ":")
  if(!is.na(es_normal) && es_normal) {
    cat(" ✓ Aproximadamente normal\n")
  } else {
    cat(" ✗ Aún no es normal\n")
  }
}

cat("\nRespuesta: La distribución se ve aproximadamente normal a partir de n = 30\n")
```
:::

---

::: {#exr-pi_simulacion}

### Simulación de Monte Carlo

Usar simulación Monte Carlo para estimar $\pi$ usando distribución uniforme.

```{r}
n_simulaciones <- c(100, 1000, 10000, 50000, 100000)
set.seed(123)

cat("SIMULACIÓN DE MONTE CARLO PARA ESTIMAR π\n")
cat("Método: Puntos aleatorios en cuadrado unitario\n")
cat("π/4 = (puntos dentro del círculo) / (total de puntos)\n\n")

estimar_pi <- function(n) {
  x <- runif(n, min = 0, max = 1)
  y <- runif(n, min = 0, max = 1)
  
  distancia <- sqrt(x^2 + y^2)
  dentro_circulo <- sum(distancia <= 1)
  
  pi_estimado <- 4 * dentro_circulo / n
  
  return(list(
    pi_estimado = pi_estimado,
    dentro = dentro_circulo,
    fuera = n - dentro_circulo,
    x = x,
    y = y,
    en_circulo = distancia <= 1
  ))
}


resultados <- list()

for(i in seq_along(n_simulaciones)) {
  n <- n_simulaciones[i]
  resultado <- estimar_pi(n)
  
  error <- abs(resultado$pi_estimado - pi)
  error_porcentual <- (error / pi) * 100
  
  resultados[[i]] <- resultado
  
  cat("n =", format(n, big.mark = ","), "\n")
  cat("  π estimado:", round(resultado$pi_estimado, 6), "\n")
  cat("  π real:", round(pi, 6), "\n")
  cat("  Error absoluto:", round(error, 6), "\n")
  cat("  Error porcentual:", round(error_porcentual, 4), "%\n")
  cat("  Puntos dentro:", resultado$dentro, "| Fuera:", resultado$fuera, "\n\n")
}
```

```{r}
resultado_viz <- resultados[[2]]

datos_puntos <- data.frame(
  x = resultado_viz$x,
  y = resultado_viz$y,
  dentro = resultado_viz$en_circulo
)

circulo <- data.frame(
  theta = seq(0, pi/2, length = 100)
) %>%
  mutate(x = cos(theta), y = sin(theta))

p1 <- ggplot() +
  geom_point(data = datos_puntos, aes(x = x, y = y, color = dentro), 
             alpha = 0.6, size = 1.5) +
  geom_path(data = circulo, aes(x = x, y = y), 
            color = "black", size = 1.2) +
  scale_color_manual(values = c("TRUE" = "#009E73", "FALSE" = "#E69F00"),
                     labels = c("Fuera del círculo", "Dentro del círculo"),
                     name = "") +
  coord_fixed() +
  labs(title = "Simulación Monte Carlo para Estimar π",
       subtitle = paste("n = 1,000 | π estimado =", round(resultado_viz$pi_estimado, 4)),
       x = "x", y = "y") +
  theme_minimal() +
  theme(legend.position = "top")

p1
```
```{r}
resultado_viz2 <- resultados[[3]]

datos_puntos2 <- data.frame(
  x = resultado_viz2$x,
  y = resultado_viz2$y,
  dentro = resultado_viz2$en_circulo
)

p2 <- ggplot() +
  geom_point(data = datos_puntos2, aes(x = x, y = y, color = dentro), 
             alpha = 0.3, size = 0.8) +
  geom_path(data = circulo, aes(x = x, y = y), 
            color = "black", size = 1.2) +
  scale_color_manual(values = c("TRUE" = "#009E73", "FALSE" = "#E69F00"),
                     labels = c("Fuera del círculo", "Dentro del círculo"),
                     name = "") +
  coord_fixed() +
  labs(title = "Simulación Monte Carlo para Estimar π",
       subtitle = paste("n = 10,000 | π estimado =", round(resultado_viz2$pi_estimado, 4)),
       x = "x", y = "y") +
  theme_minimal() +
  theme(legend.position = "top")

p2
```

```{r}
# Tabla resumen de todas las simulaciones
tabla_resumen <- data.frame(
  `Número de puntos` = format(n_simulaciones, big.mark = ","),
  `π estimado` = sapply(resultados, function(x) round(x$pi_estimado, 6)),
  `π real` = round(pi, 6),
  `Error absoluto` = sapply(resultados, function(x) round(abs(x$pi_estimado - pi), 6)),
  `Error (%)` = sapply(resultados, function(x) round(abs(x$pi_estimado - pi) / pi * 100, 4)),
  `Puntos dentro` = sapply(resultados, function(x) format(x$dentro, big.mark = ",")),
  `Puntos fuera` = sapply(resultados, function(x) format(x$fuera, big.mark = ","))
)

kable(tabla_resumen,
      align = "c",
      caption = "Convergencia de la Estimación de π con Monte Carlo") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE)

```

:::

